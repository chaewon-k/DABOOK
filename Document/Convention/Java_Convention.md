# Naming

1. 변수 및 파일 이름에는 숫자, 영어만을 사용하여 정의한다
2. 파일명은 SnakeCase를 적용한다.
    - ex) log_회원id_책이름_날짜시간
3. 패키지는 소문자로 구성한다.
    - 언더바(_), 대문자를 이용하지 않고 구성한다.
4. 클래스, 인터페이스의 경우 대문자 CamelCase를 적용한다.
    - ex) FileList
5. 메서드(함수)의 경우 동사(소문자)로 시작하는 CamelCase를 적용한다.
    - 목적어 기입(Address, 전체, 파일 이름 등)
    - 함수의 부수효과가 있다면 기입(getOrDefault 등)
    - 매개변수 이름 기입
    - ex) findAllByName, findFileListByName
6. 변수의 경우 CamelCase를 적용한다.
    - ex) userName, fileName
7. 컬렉션은 자료구조의 이름을 사용하여 구성한다.
    - ex) List<File> fileList = new ArrayList<>();
    - ex) Map<String.File> fileMap = new HashMap<>();
8. URL은 최대한 간단하게 하되 동사는 사용을 금지한다.
    - 소문자를 사용한다.
    - 마지막에 슬래시(/)를 포함하지 않는다.(엄근진)
    - 언더바를 대신 하이픈을 사용한다.(최소화)
    - 파일 확장자는 URI에 포함시키지 않는다.
9. 상수의 경우 대문자 SnakeCase를 사용한다.
    - ex) DATA_CONNECTION
    - 

## Structure

구조 설계에 대한 고민은 항상하기 마련이다. 좋은 설계를 위해 꾸준히 고민하고 리팩토링 작업하는 것을 지향한다.

1. 패키지는 목적별로 묶는다.
    - user(User 관련 패키지), coupon(쿠폰 관련 패키지)
2. Controller에서는 최대한 어떤 Service를 호출할지 결정하는 역할과 Exception처리만을 담당하자.
    - Controller 단에서 로직을 구현하는 것을 지양한다.
    - Controller의 코드 라인 수를 줄이자는 뜻은 절대 아니다.
3. 하나의 메소드와 클래스는 하나의 목적을 두게 만든다.
    - 하나의 메소드 안에서 한가지 일만 해야한다.
    - 하나의 클래스 안에서는 같은 목적을 둔 코드들의 집합이여야한다.
4. 메소드와 클래스는 최대한 작게 만든다.
    - 메소드와 클래스가 커진다면 하나의 클래스나 메소드 안에서 여러 동작을 하고 있을 확률이 크다.
    - 수많은 책임을 떠안은 클래스를 피한다. 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더욱 바람직하다.
    - 클래스 나누는 것을 두려워하지 말자.
5. 도메인 서비스를 만들어지는 것을 피하자.
    - User라는 도메인이 있을 때, UserService로 만드는 것을 피한다.
    - 이렇게 도메인 네이밍을 딴 서비스가 만들어지면 자연스레 수많은 책임을 떠안은 큰 클래스로 발전될 가능성이 높다.
    - 기능 별로 세분화해서 만들어보자. (UserRegisterService, UserEmailService 등...)

## Programming

1. 반복되는 코드를 작성하지 않는다.
    - 단, 테스트코드는 예외로 한다.
2. 변수는 최대한 사용하는 위치에 가깝게 사용한다.
3. 파라미터 변수와 내부 변수를 구별할 땐 언더바가 아닌 this로 구별한다.
    - this.name = name (O) / name = _name (X)
    - 추가적으로 언더바를 prefix로 사용하는 것을 지양하자.
4. 코드의 길이가 짧고 명료한 것도 좋지만, **가독성이 현저히 떨어진다면 코드를 좀 더 풀어쓴다.**
    - 무조건적으로 코드가 짧은 것이 좋다고 생각하지 않는다. 다른 개발자가 본다면 가독성이 현저히 떨어진다.
    - 특히나 최신 언어(kotlin 등)의 경우 코드의 길이를 현저히 줄일 수도 있지만, 제3자의 입장에서 봐도 어느정도 가독성이 있는지 다시 한번 확인하는 작업을 하자.
5. 모든 예외는 무시하지말고 처리한다. 만약 예외를 처리하지 않을거라면 그 이유에 대해서 명확하게 주석을 남긴다.
6. 예외를 던질 때는 최대한 세부적인 Exception(= Custom Exception)을 던진다.
    - 실패한 코드의 의도를 파악하려면 호출 스택트레이스만으로 부족하다.
    - 오류 메세지에 전후 상황의 정보를 담아 예외와 함께 던진다.
7. 예외 케이스가 발생할 확률이 있는 경우, 가능한 빨리 리턴 또는 예외를 던지도록 작성한다.
    - 쓸데없이 정상로직을 태울 필요가 없게한다.

        ```
        if(!정상) {
          throw err;
        }
        정상 로직
        }
        ```

8. 조건이 복잡한 경우 임시 boolean 변수를 만들어 단순화한다.
9. 조건문에 부정조건을 넣는 것을 피한다.
    - if(status.isNormal()) (O) / if(!status.isAbnormal()) (X)
10. 최대한 객체 타입 대신 기본 자료형을 선택하고, 생각지도 못한 Autoboxing이 발생하지 않도록 유의한다.

# DB

1. 키를 전부 소문자로 적고, 축약하지 말자
   - filename → fn(X)
2. 통용되는 축약어만 사용하자